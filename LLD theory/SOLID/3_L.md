## 4) L - Liskov Substitution Principle (LSP)

### The Liskov Substitution Principle (LSP) states:
ðŸ‘‰ "Subtypes must be substitutable for their base types without altering the correctness of the program."

### Key Points
- A child class should be able to replace its parent class without breaking the application.
- A subclass should extend behavior, not weaken or break it.

## ðŸš¨ Violating Liskov Substitution Principle
Let's take an example where LSP is violated:

```java
class Rectangle {
    protected int width, height;

    public void setWidth(int width) { this.width = width; }
    public void setHeight(int height) { this.height = height; }

    public int getArea() { return width * height; }
}
```

Now, let's create a subclass `Square`:

```java
class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        super.width = width;
        super.height = width; // Enforces square property
    }

    @Override
    public void setHeight(int height) {
        super.width = height;
        super.height = height; // Enforces square property
    }
}
```

### ðŸš¨ Why does this violate LSP?
If we replace a `Rectangle` with a `Square`, it breaks expected behavior:

```java
public class Main {
    public static void main(String[] args) {
        Rectangle rect = new Square();
        rect.setWidth(4);
        rect.setHeight(5);

        System.out.println(rect.getArea()); // Expected: 4 * 5 = 20, but gets 5 * 5 = 25
    }
}
```

ðŸ’¥ **Issue:** A `Square` does not behave like a `Rectangle`, because width and height should be independent in a rectangle but equal in a square.
This breaks the applicationâ€™s logic when using polymorphism.

## âœ… Fixing the Issue
Instead of forcing `Square` to extend `Rectangle`, we should introduce a common interface:

```java
interface Shape {
    int getArea();
}
```

### Corrected Implementation
```java
class Rectangle implements Shape {
    protected int width, height;

    public Rectangle(int width, int height) {
        this.width = width;
        this.height = height;
    }

    @Override
    public int getArea() {
        return width * height;
    }
}
```

```java
class Square implements Shape {
    private int side;

    public Square(int side) {
        this.side = side;
    }

    @Override
    public int getArea() {
        return side * side;
    }
}
```

Now, both `Rectangle` and `Square` implement `Shape`, and we can substitute them without breaking behavior:

```java
public class Main {
    public static void printArea(Shape shape) {
        System.out.println("Area: " + shape.getArea());
    }

    public static void main(String[] args) {
        Shape rect = new Rectangle(4, 5);
        Shape square = new Square(4);

        printArea(rect);   // âœ… Output: 20
        printArea(square); // âœ… Output: 16
    }
}
```

### ðŸ”¹ Summary of LSP
âœ” A child class should behave as a proper substitute for its parent.
âœ” Avoid breaking expected behavior when using polymorphism.
âœ” Prefer interfaces over deep inheritance when behaviors differ.

By following LSP, our code remains robust, scalable, and easy to maintain. ðŸš€
